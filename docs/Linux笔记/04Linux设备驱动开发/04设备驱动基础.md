/sys/firmware/devicetree/base
目录下增加设备节点

/sys/devices/platform
内核解析后的 包含各种属性

装在驱动好后增加driver目录
ls -l

/sys/bus/platform/drivers

insmod
modprobe
rmmod
	用户空间工具, 加载模块到运行中的内核以及去除它们.

\#include <linux/init.h>

module_init(init_function);
module_exit(cleanup_function);
	指定模块的初始化和清理函数的宏定义.

__init
__initdata
__exit
__exitdata
	函数( __init 和 __exit )和数据(__initdata 和 __exitdata ) 的标记, 只用在模块初始化或者清理时间.为初始化所标识的项可能会在初始化完成后丢弃;退出的项可能被丢弃如果内核没有配置模块卸载. 这些标记通过使相关的目标在可执行文件的特定的 ELF 节里被替换来工作.

\#include <linux/sched.h>
	最重要的头文件中的一个. 这个文件包含很多驱动使用的内核 API 的定义, 包括睡
眠函数和许多变量声明.

struct task_struct *current;
	当前进程.

current->pid
current->comm
	进程 ID 和 当前进程的命令名.

obj-m
	一个 makefile 符号, 内核建立系统用来决定当前目录下的哪个模块应当被建立.

/sys/module
/proc/modules
/sys/module 
	是一个 sysfs 目录层次, 包含当前加载模块的信息. /proc/moudles
是旧式的, 那种信息的单个文件版本. 其中的条目包含了模块名, 每个模块占用的
内存数量, 以及使用计数. 另外的字串追加到每行的末尾来指定标志, 对这个模块
当前是活动的.

vermagic.o
	来自内核源码目录的目标文件, 描述一个模块为之建立的环境.

EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL (symbol);
	宏定义, 用来输出一个符号给内核. 第 2 种形式输出没有版本信息, 第 3 种限制
输出给 GPL 许可的模块.

MODULE_AUTHOR(author);
MODULE_DESCRIPTION(description);
MODULE_VERSION(version_string);
MODULE_DEVICE_TABLE(table_info);
MODULE_ALIAS(alternate_name);
	放置文档在目标文件的模块中.

module_init(init_function);
module_exit(exit_function);
	宏定义, 声明一个模块的初始化和清理函数.

\#include <linux/moduleparam.h>
module_param(variable, type, perm);
	宏定义, 创建模块参数, 可以被用户在模块加载时调整( 或者在启动时间, 对于内
嵌代码). 类型可以是 bool, charp, int, invbool, short, ushort, uint, ulong,
或者 intarray.

\#include <linux/kernel.h>
int printk(const char * fmt, ...);
	内核代码的 printf 类似物.

\#include <linux/module.h>

	必需的头文件. 它必须在一个模块源码中包含.

\#include <linux/version.h>
	头文件, 包含在建立的内核版本信息.

LINUX_VERSION_CODE
	整型宏定义, 对 #ifdef 版本依赖有用.
	
## 字符驱动

### 1 主次编号
\#include <linux/types.h>
dev_t
	dev_t 是用来在内核里代表设备号的类型.

MAJOR(dev_t dev);
MINOR(dev_t dev);
	获得一个 dev_t 的主或者次编号

MKDEV(int major, int minor);
	主次编号转换为一个 dev_t

### 2 主要的数据结构

1. 文件操作：
file_operations
2. 文件结构：
file
3. inode 结构：
inode

unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);
	从一个 inode 中获取主次编号
	


### 3 字符设备注册

\#include <linux/cdev.h>
struct cdev *cdev_alloc(void);
void cdev_init(struct cdev *dev, struct file_operations *fops);
int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
void cdev_del(struct cdev *dev);
	cdev 结构管理的函数, 它代表内核中的字符设备.
	
\#include <linux/kernel.h>
container_of(pointer, type, field);
	一个传统宏定义, 可用来获取一个结构指针, 从它里面包含的某个其他结构的指针.
	
\#include <linux/fs.h>
	"文件系统"头文件是编写设备驱动需要的头文件. 许多重要的函数和数据结构在此
定义.

int register_chrdev_region(dev_t first, unsigned int count, char *name);
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
void unregister_chrdev_region(dev_t first, unsigned int count);
	允许驱动分配和释放设备编号的范围的函数. register_chrdev_region 应当用在事先知道需要的主编号时; 对于动态分配, 使用 alloc_chrdev_region 代替.

int register_chrdev(unsigned int major, const char *name, struct
file_operations *fops);
	老的( 2.6 之前) 字符设备注册函数. 它在 2.6 内核中被模拟, 但是不应当给新代
码使用. 如果主编号不是 0, 可以不变地用它; 否则一个动态编号被分配给这个设
备.

int unregister_chrdev(unsigned int major, const char *name);
	恢复一个由 register_chrdev 所作的注册的函数. major 和 name 字符串必须包含之前用来注册设备时同样的值.

### 4 文件操作方法实现
open
int open(struct inode *inode, struct file *filp)
	open 方法提供给驱动来做任何的初始化来准备后续的操作. 在大部分驱动中, open 应当进行下面的工作:
	• 检查设备特定的错误(例如设备没准备好, 或者类似的硬件错误
	• 如果它第一次打开, 初始化设备
	• 如果需要, 更新 f_op 指针.
	• 分配并填充要放进 filp->private_data 的任何数据结构

release
int release(struct inode *inode, struct file *filp)
	release 方法的角色是 open 的反面. 有时你会发现方法的实现称为 device_close, 而不
是 device_release. 任一方式, 设备方法应当进行下面的任务:
	• 释放 open 分配在 filp->private_data 中的任何东西
	• 在最后的 close 关闭设备

read 和 write
ssize_t scull_write(struct file *filp, const char __user *buff, size_t count, loff_t *offp)
ssize_t scull_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
	read 和 write 方法的 buff 参数是用户空间指针. 因此, 它不能被内
	核代码直接解引用. 这个限制有几个理由:
	• 依赖于你的驱动运行的体系, 以及内核被如何配置的, 用户空间指针当运行于内核
	模式可能根本是无效的. 可能没有那个地址的映射, 或者它可能指向一些其他的随
	机数据.
	• 就算这个指针在内核空间是同样的东西, 用户空间内存是分页的, 在做系统调用时
	这个内存可能没有在 RAM 中. 试图直接引用用户空间内存可能产生一个页面错, 这
	是内核代码不允许做的事情. 结果可能是一个"oops", 导致进行系统调用的进程死
	亡.
	• 置疑中的指针由一个用户程序提供, 它可能是错误的或者恶意的. 如果你的驱动盲
	目地解引用一个用户提供的指针, 它提供了一个打开的门路使用户空间程序存取或
	覆盖系统任何地方的内存. 如果你不想负责你的用户的系统的安全危险, 你就不能
	直接解引用用户空间指针.

\#include <asm/uaccess.h>
	这个包含文件声明内核代码使用的函数来移动数据到和从用户空间.
unsigned long copy_from_user (void *to, const void *from, unsigned long count);
unsigned long copy_to_user (void *to, const void *from, unsigned long count);
	在用户空间和内核空间拷贝数据.





